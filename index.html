<script>
const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const baseNote = 60;
const totalOctaves = 2;

let midiOutput = null;
let currentRoot = "C";
let currentScale = "major";
let currentOctave = 2;
let slideMode = false;
let expressionMode = false;

// --- Active touches: multi-touch tracking ---
let activeTouches = {}; // touchId -> { noteEl, slideStartX }

// --- DOM Elements ---
const piano = document.getElementById('piano');
const rootSelect = document.getElementById('rootSelect');
const scaleSelect = document.getElementById('scaleSelect');
const octaveSelect = document.getElementById('octaveSelect');
const midiOutSelect = document.getElementById('midiOut');
const slideToggle = document.getElementById('slideToggle');
const expressionToggle = document.getElementById('expressionToggle');

// --- MIDI Setup ---
navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);

function onMIDISuccess(midiAccess) {
    for (const output of midiAccess.outputs.values()) {
        const option = document.createElement('option');
        option.value = output.id;
        option.textContent = output.name;
        midiOutSelect.appendChild(option);
    }

    const first = midiOutSelect.options[0];
    if (first) { 
        midiOutput = midiAccess.outputs.get(first.value);
        midiOutSelect.value = first.value;
    }

    midiOutSelect.addEventListener('change', e => {
        midiOutput = midiAccess.outputs.get(e.target.value);
    });

    ['cc1','cc2','cc3','cc4'].forEach((id,i) => {
        const slider = document.getElementById(id);
        slider.addEventListener('input', () => {
            if (!midiOutput) return;
            const ccNum = [11,21,22,23][i];
            midiOutput.send([0xB0, ccNum, parseInt(slider.value)]);
        });
    });

    rootSelect.addEventListener('change', e => { currentRoot = e.target.value; updateScaleLabels(); });
    scaleSelect.addEventListener('change', e => { currentScale = e.target.value; updateScaleLabels(); });
    octaveSelect.addEventListener('change', e => { currentOctave = parseInt(e.target.value); });

    buildPiano();
    updateScaleLabels();
}

function onMIDIFailure() { alert("Web MIDI not supported or permission denied."); }

// --- Slide & Expression Toggles ---
slideToggle.addEventListener('click', () => {
    slideMode = !slideMode;
    slideToggle.textContent = 'Slide Mode: ' + (slideMode ? 'ON' : 'OFF');
    document.querySelectorAll('.key.active').forEach(k => k.classList.remove('active'));
    activeTouches = {};
    midiOutput?.send([0xE0, 0, 64]); // reset pitch bend
});

expressionToggle.addEventListener('click', () => {
    expressionMode = !expressionMode;
    expressionToggle.textContent = 'Expression per Note: ' + (expressionMode ? 'ON' : 'OFF');
});

// --- Build Piano Keys ---
function buildPiano() {
    piano.innerHTML = '';
    for (let o=0;o<totalOctaves;o++) {
        for (let i=0;i<12;i++) {
            const noteName = noteNames[i]+(4+o);
            const midiNote = baseNote + o*12 + i;

            const container = document.createElement('div');
            container.classList.add('key-container');
            if (i===0 && o>0) container.classList.add('octave-separator');

            const degreeLabel = document.createElement('div');
            degreeLabel.classList.add('degree');
            container.appendChild(degreeLabel);

            const key = document.createElement('div');
            key.classList.add('key');
            key.classList.add([1,3,6,8,10].includes(i)? 'black' : 'white');
            key.dataset.note = midiNote;
            key.dataset.name = noteNames[i];
            key.textContent = noteName;

            container.appendChild(key);
            piano.appendChild(container);
        }
    }
}

// --- Helpers ---
function getTransposedNote(midiNote) {
    const rootOffset = noteNames.indexOf(currentRoot);
    const octaveOffset = (currentOctave - 2) * 12;
    return midiNote + rootOffset + octaveOffset;
}

function noteOnKey(keyEl, velocity=100) {
    if (!midiOutput) return;
    const midiNote = getTransposedNote(parseInt(keyEl.dataset.note));
    keyEl.classList.add('active');
    midiOutput.send([0x90, midiNote, velocity]);
}

function noteOffKey(keyEl) {
    if (!midiOutput) return;
    const midiNote = getTransposedNote(parseInt(keyEl.dataset.note));
    keyEl.classList.remove('active');
    midiOutput.send([0x80, midiNote, 0]);
}

function updateExpression(keyEl, clientY) {
    if (!midiOutput) return;
    const rect = keyEl.getBoundingClientRect();
    let value = Math.round((rect.bottom - clientY) / rect.height * 127);
    value = Math.max(0, Math.min(127, value));
    midiOutput.send([0xB0, 11, value]);
}

function updateSlidePitch(touchData) {
    if (!midiOutput || !touchData) return;
    const { noteEl, slideStartX } = touchData;

    const distance = touchData.clientX - slideStartX;

    const keys = Array.from(document.querySelectorAll('.key')).map(k => ({
        el: k,
        note: parseInt(k.dataset.note),
        rect: k.getBoundingClientRect()
    }));

    const startC = keys.find(k => k.note % 12 === 0);
    const nextC = keys.find(k => k.note % 12 === 0 && k.note > startC.note);
    if (!startC || !nextC) return;

    const octaveWidthPx = nextC.rect.left - startC.rect.left;
    const bend = Math.max(-8192, Math.min(8191, Math.round((distance / octaveWidthPx) * 8192)));
    const value = bend + 8192;
    midiOutput.send([0xE0, value & 0x7F, (value >> 7) & 0x7F]);
}

// --- Multi-touch Event Handlers ---
document.addEventListener('touchstart', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!target || !target.classList.contains('key')) continue;

        const velocity = expressionMode ? Math.round((target.getBoundingClientRect().bottom - touch.clientY)/target.getBoundingClientRect().height*127) : 100;

        noteOnKey(target, velocity);
        activeTouches[touch.identifier] = { noteEl: target, slideStartX: touch.clientX, clientX: touch.clientX };
    }
}, { passive: false });

document.addEventListener('touchmove', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        const data = activeTouches[touch.identifier];
        if (!data) continue;
        data.clientX = touch.clientX; // update current X

        if (slideMode) updateSlidePitch(data);
        if (expressionMode) updateExpression(data.noteEl, touch.clientY);
    }
}, { passive: false });

document.addEventListener('touchend', e => {
    e.preventDefault();
    for (const touch of e.changedTouches) {
        const data = activeTouches[touch.identifier];
        if (!data) continue;

        noteOffKey(data.noteEl);
        delete activeTouches[touch.identifier];
    }

    if (slideMode && Object.keys(activeTouches).length === 0) {
        midiOutput?.send([0xE0, 0, 64]); // reset pitch bend when all touches released
    }
}, { passive: false });

// --- Desktop Mouse Events (single pointer fallback) ---
document.addEventListener('mousedown', e => {
    if (!e.target.classList.contains('key')) return;
    const keyEl = e.target;
    noteOnKey(keyEl);
    lastMouseKey = keyEl;
});

document.addEventListener('mousemove', e => {
    if (!lastMouseKey) return;
    const target = document.elementFromPoint(e.clientX, e.clientY);
    if (target && target.classList.contains('key') && target !== lastMouseKey) {
        noteOffKey(lastMouseKey);
        noteOnKey(target);
        lastMouseKey = target;
    }
});

document.addEventListener('mouseup', e => {
    if (lastMouseKey) noteOffKey(lastMouseKey);
    lastMouseKey = null;
});

// --- Scale Labels ---
function updateScaleLabels() {
    const rootIndex = noteNames.indexOf(currentRoot);
    const intervals = currentScale === "major" ? [0,2,4,5,7,9,11] : [0,2,3,5,7,8,10];
    const scaleNotes = intervals.map(i => (rootIndex+i)%12);
    const degreeMap = {};
    scaleNotes.forEach((n,i)=>degreeMap[n]=i+1);

    document.querySelectorAll('.key-container').forEach(container=>{
        const key = container.querySelector('.key');
        const label = container.querySelector('.degree');
        const noteIndex = noteNames.indexOf(key.dataset.name);
        label.textContent=""; label.classList.remove('root');
        if(noteIndex===rootIndex) { label.textContent="1"; label.classList.add('root'); }
        else if(degreeMap[noteIndex]) label.textContent = degreeMap[noteIndex];
    });
}
</script>
